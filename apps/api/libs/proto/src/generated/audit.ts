// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v5.29.3
// source: audit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Timestamp } from "./google/protobuf/timestamp";
import { messageTypeRegistry } from "./typeRegistry";

export const protobufPackage = "api.audit";

/** packages/proto/src/audit.proto */

export interface RecordActionRequest {
  $type: "api.audit.RecordActionRequest";
  userId: string;
  action: string;
  entityType: string;
  entityId: string;
  details?: string | undefined;
  /** JSON string */
  metadata?: string | undefined;
  createdAt?: Timestamp | undefined;
}

export interface RecordActionResponse {
  $type: "api.audit.RecordActionResponse";
  id: string;
}

export interface GetLogsByUserRequest {
  $type: "api.audit.GetLogsByUserRequest";
  userId: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface GetLogsByUserResponse {
  $type: "api.audit.GetLogsByUserResponse";
  logs: AuditLogEntry[];
  total: number;
}

export interface GetAllLogsRequest {
  $type: "api.audit.GetAllLogsRequest";
  limit?: number | undefined;
  offset?: number | undefined;
  action?: string | undefined;
  entityType?: string | undefined;
  userId?: string | undefined;
  startDate?: Timestamp | undefined;
  endDate?: Timestamp | undefined;
}

export interface GetAllLogsResponse {
  $type: "api.audit.GetAllLogsResponse";
  logs: AuditLogEntry[];
  total: number;
}

export interface AuditLogEntry {
  $type: "api.audit.AuditLogEntry";
  id: string;
  userId: string;
  action: string;
  entityType: string;
  entityId: string;
  details?: string | undefined;
  /** JSON string */
  metadata?: string | undefined;
  createdAt?: Timestamp | undefined;
}

export const API_AUDIT_PACKAGE_NAME = "api.audit";

function createBaseRecordActionRequest(): RecordActionRequest {
  return {
    $type: "api.audit.RecordActionRequest",
    userId: "",
    action: "",
    entityType: "",
    entityId: "",
  };
}

export const RecordActionRequest: MessageFns<
  RecordActionRequest,
  "api.audit.RecordActionRequest"
> = {
  $type: "api.audit.RecordActionRequest" as const,

  encode(
    message: RecordActionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.entityType !== "") {
      writer.uint32(26).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(34).string(message.entityId);
    }
    if (message.details !== undefined) {
      writer.uint32(42).string(message.details);
    }
    if (message.metadata !== undefined) {
      writer.uint32(50).string(message.metadata);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RecordActionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.details = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(RecordActionRequest.$type, RecordActionRequest);

function createBaseRecordActionResponse(): RecordActionResponse {
  return { $type: "api.audit.RecordActionResponse", id: "" };
}

export const RecordActionResponse: MessageFns<
  RecordActionResponse,
  "api.audit.RecordActionResponse"
> = {
  $type: "api.audit.RecordActionResponse" as const,

  encode(
    message: RecordActionResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RecordActionResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(RecordActionResponse.$type, RecordActionResponse);

function createBaseGetLogsByUserRequest(): GetLogsByUserRequest {
  return { $type: "api.audit.GetLogsByUserRequest", userId: "" };
}

export const GetLogsByUserRequest: MessageFns<
  GetLogsByUserRequest,
  "api.audit.GetLogsByUserRequest"
> = {
  $type: "api.audit.GetLogsByUserRequest" as const,

  encode(
    message: GetLogsByUserRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int32(message.offset);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetLogsByUserRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLogsByUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetLogsByUserRequest.$type, GetLogsByUserRequest);

function createBaseGetLogsByUserResponse(): GetLogsByUserResponse {
  return { $type: "api.audit.GetLogsByUserResponse", logs: [], total: 0 };
}

export const GetLogsByUserResponse: MessageFns<
  GetLogsByUserResponse,
  "api.audit.GetLogsByUserResponse"
> = {
  $type: "api.audit.GetLogsByUserResponse" as const,

  encode(
    message: GetLogsByUserResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.logs) {
      AuditLogEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetLogsByUserResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLogsByUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(AuditLogEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetLogsByUserResponse.$type, GetLogsByUserResponse);

function createBaseGetAllLogsRequest(): GetAllLogsRequest {
  return { $type: "api.audit.GetAllLogsRequest" };
}

export const GetAllLogsRequest: MessageFns<
  GetAllLogsRequest,
  "api.audit.GetAllLogsRequest"
> = {
  $type: "api.audit.GetAllLogsRequest" as const,

  encode(
    message: GetAllLogsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.limit !== undefined) {
      writer.uint32(8).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(16).int32(message.offset);
    }
    if (message.action !== undefined) {
      writer.uint32(26).string(message.action);
    }
    if (message.entityType !== undefined) {
      writer.uint32(34).string(message.entityType);
    }
    if (message.userId !== undefined) {
      writer.uint32(42).string(message.userId);
    }
    if (message.startDate !== undefined) {
      Timestamp.encode(message.startDate, writer.uint32(50).fork()).join();
    }
    if (message.endDate !== undefined) {
      Timestamp.encode(message.endDate, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllLogsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.endDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetAllLogsRequest.$type, GetAllLogsRequest);

function createBaseGetAllLogsResponse(): GetAllLogsResponse {
  return { $type: "api.audit.GetAllLogsResponse", logs: [], total: 0 };
}

export const GetAllLogsResponse: MessageFns<
  GetAllLogsResponse,
  "api.audit.GetAllLogsResponse"
> = {
  $type: "api.audit.GetAllLogsResponse" as const,

  encode(
    message: GetAllLogsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.logs) {
      AuditLogEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAllLogsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(AuditLogEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetAllLogsResponse.$type, GetAllLogsResponse);

function createBaseAuditLogEntry(): AuditLogEntry {
  return {
    $type: "api.audit.AuditLogEntry",
    id: "",
    userId: "",
    action: "",
    entityType: "",
    entityId: "",
  };
}

export const AuditLogEntry: MessageFns<
  AuditLogEntry,
  "api.audit.AuditLogEntry"
> = {
  $type: "api.audit.AuditLogEntry" as const,

  encode(
    message: AuditLogEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    if (message.entityType !== "") {
      writer.uint32(34).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(42).string(message.entityId);
    }
    if (message.details !== undefined) {
      writer.uint32(50).string(message.details);
    }
    if (message.metadata !== undefined) {
      writer.uint32(58).string(message.metadata);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLogEntry {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.details = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(AuditLogEntry.$type, AuditLogEntry);

export interface AuditServiceClient {
  recordAction(request: RecordActionRequest): Observable<RecordActionResponse>;

  getLogsByUser(
    request: GetLogsByUserRequest,
  ): Observable<GetLogsByUserResponse>;

  getAllLogs(request: GetAllLogsRequest): Observable<GetAllLogsResponse>;
}

export interface AuditServiceController {
  recordAction(
    request: RecordActionRequest,
  ):
    | Promise<RecordActionResponse>
    | Observable<RecordActionResponse>
    | RecordActionResponse;

  getLogsByUser(
    request: GetLogsByUserRequest,
  ):
    | Promise<GetLogsByUserResponse>
    | Observable<GetLogsByUserResponse>
    | GetLogsByUserResponse;

  getAllLogs(
    request: GetAllLogsRequest,
  ):
    | Promise<GetAllLogsResponse>
    | Observable<GetAllLogsResponse>
    | GetAllLogsResponse;
}

export function AuditServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "recordAction",
      "getLogsByUser",
      "getAllLogs",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcMethod("AuditService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcStreamMethod("AuditService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
  };
}

export const AUDIT_SERVICE_NAME = "AuditService";

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
