// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v5.29.3
// source: notification.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { messageTypeRegistry } from "./typeRegistry";

export const protobufPackage = "api.notification";

/** apps/api/libs/proto/src/proto/notification.proto */

export interface SendNotificationRequest {
  $type: "api.notification.SendNotificationRequest";
  userId: string;
  title: string;
  message: string;
  /** e.g., BOOKING_APPROVED, ITEM_DUE, ITEM_RETURNED */
  type: string;
  /** optional json string */
  metadata: string;
}

export interface SendNotificationResponse {
  $type: "api.notification.SendNotificationResponse";
  success: boolean;
}

export interface GetUserNotificationsRequest {
  $type: "api.notification.GetUserNotificationsRequest";
  userId: string;
}

export interface GetUserNotificationsResponse {
  $type: "api.notification.GetUserNotificationsResponse";
  notifications: Notification[];
}

export interface MarkNotificationAsReadRequest {
  $type: "api.notification.MarkNotificationAsReadRequest";
  notificationId: string;
}

export interface MarkNotificationAsReadResponse {
  $type: "api.notification.MarkNotificationAsReadResponse";
  success: boolean;
}

export interface Notification {
  $type: "api.notification.Notification";
  id: string;
  title: string;
  message: string;
  type: string;
  read: boolean;
  createdAt: string;
}

export const API_NOTIFICATION_PACKAGE_NAME = "api.notification";

function createBaseSendNotificationRequest(): SendNotificationRequest {
  return {
    $type: "api.notification.SendNotificationRequest",
    userId: "",
    title: "",
    message: "",
    type: "",
    metadata: "",
  };
}

export const SendNotificationRequest: MessageFns<
  SendNotificationRequest,
  "api.notification.SendNotificationRequest"
> = {
  $type: "api.notification.SendNotificationRequest" as const,

  encode(
    message: SendNotificationRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.metadata !== "") {
      writer.uint32(42).string(message.metadata);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SendNotificationRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(SendNotificationRequest.$type, SendNotificationRequest);

function createBaseSendNotificationResponse(): SendNotificationResponse {
  return { $type: "api.notification.SendNotificationResponse", success: false };
}

export const SendNotificationResponse: MessageFns<
  SendNotificationResponse,
  "api.notification.SendNotificationResponse"
> = {
  $type: "api.notification.SendNotificationResponse" as const,

  encode(
    message: SendNotificationResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SendNotificationResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendNotificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  SendNotificationResponse.$type,
  SendNotificationResponse,
);

function createBaseGetUserNotificationsRequest(): GetUserNotificationsRequest {
  return { $type: "api.notification.GetUserNotificationsRequest", userId: "" };
}

export const GetUserNotificationsRequest: MessageFns<
  GetUserNotificationsRequest,
  "api.notification.GetUserNotificationsRequest"
> = {
  $type: "api.notification.GetUserNotificationsRequest" as const,

  encode(
    message: GetUserNotificationsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetUserNotificationsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  GetUserNotificationsRequest.$type,
  GetUserNotificationsRequest,
);

function createBaseGetUserNotificationsResponse(): GetUserNotificationsResponse {
  return {
    $type: "api.notification.GetUserNotificationsResponse",
    notifications: [],
  };
}

export const GetUserNotificationsResponse: MessageFns<
  GetUserNotificationsResponse,
  "api.notification.GetUserNotificationsResponse"
> = {
  $type: "api.notification.GetUserNotificationsResponse" as const,

  encode(
    message: GetUserNotificationsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.notifications) {
      Notification.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetUserNotificationsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserNotificationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notifications.push(
            Notification.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  GetUserNotificationsResponse.$type,
  GetUserNotificationsResponse,
);

function createBaseMarkNotificationAsReadRequest(): MarkNotificationAsReadRequest {
  return {
    $type: "api.notification.MarkNotificationAsReadRequest",
    notificationId: "",
  };
}

export const MarkNotificationAsReadRequest: MessageFns<
  MarkNotificationAsReadRequest,
  "api.notification.MarkNotificationAsReadRequest"
> = {
  $type: "api.notification.MarkNotificationAsReadRequest" as const,

  encode(
    message: MarkNotificationAsReadRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.notificationId !== "") {
      writer.uint32(10).string(message.notificationId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MarkNotificationAsReadRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkNotificationAsReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notificationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  MarkNotificationAsReadRequest.$type,
  MarkNotificationAsReadRequest,
);

function createBaseMarkNotificationAsReadResponse(): MarkNotificationAsReadResponse {
  return {
    $type: "api.notification.MarkNotificationAsReadResponse",
    success: false,
  };
}

export const MarkNotificationAsReadResponse: MessageFns<
  MarkNotificationAsReadResponse,
  "api.notification.MarkNotificationAsReadResponse"
> = {
  $type: "api.notification.MarkNotificationAsReadResponse" as const,

  encode(
    message: MarkNotificationAsReadResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): MarkNotificationAsReadResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkNotificationAsReadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  MarkNotificationAsReadResponse.$type,
  MarkNotificationAsReadResponse,
);

function createBaseNotification(): Notification {
  return {
    $type: "api.notification.Notification",
    id: "",
    title: "",
    message: "",
    type: "",
    read: false,
    createdAt: "",
  };
}

export const Notification: MessageFns<
  Notification,
  "api.notification.Notification"
> = {
  $type: "api.notification.Notification" as const,

  encode(
    message: Notification,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.read !== false) {
      writer.uint32(40).bool(message.read);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.read = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(Notification.$type, Notification);

export interface NotificationServiceClient {
  sendNotification(
    request: SendNotificationRequest,
  ): Observable<SendNotificationResponse>;

  getUserNotifications(
    request: GetUserNotificationsRequest,
  ): Observable<GetUserNotificationsResponse>;

  markNotificationAsRead(
    request: MarkNotificationAsReadRequest,
  ): Observable<MarkNotificationAsReadResponse>;
}

export interface NotificationServiceController {
  sendNotification(
    request: SendNotificationRequest,
  ):
    | Promise<SendNotificationResponse>
    | Observable<SendNotificationResponse>
    | SendNotificationResponse;

  getUserNotifications(
    request: GetUserNotificationsRequest,
  ):
    | Promise<GetUserNotificationsResponse>
    | Observable<GetUserNotificationsResponse>
    | GetUserNotificationsResponse;

  markNotificationAsRead(
    request: MarkNotificationAsReadRequest,
  ):
    | Promise<MarkNotificationAsReadResponse>
    | Observable<MarkNotificationAsReadResponse>
    | MarkNotificationAsReadResponse;
}

export function NotificationServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "sendNotification",
      "getUserNotifications",
      "markNotificationAsRead",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcMethod("NotificationService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcStreamMethod("NotificationService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
  };
}

export const NOTIFICATION_SERVICE_NAME = "NotificationService";

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
