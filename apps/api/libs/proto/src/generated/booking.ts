// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v5.29.3
// source: booking.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Timestamp } from "./google/protobuf/timestamp";
import { messageTypeRegistry } from "./typeRegistry";

export const protobufPackage = "api.booking";

/** apps/api/libs/proto/src/proto/booking.proto */

export interface User {
  $type: "api.booking.User";
  id: string;
  email: string;
  username: string;
}

export interface Booking {
  $type: "api.booking.Booking";
  id: string;
  itemId: string;
  userId: string;
  startTime?: Timestamp | undefined;
  endTime?: Timestamp | undefined;
  note: string;
  /** e.g., Pending, Approved, Cancelled */
  status: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
}

export interface GetBookingsRequest {
  $type: "api.booking.GetBookingsRequest";
  user?: User | undefined;
}

export interface GetAllBookingsRequest {
  $type: "api.booking.GetAllBookingsRequest";
  user?: User | undefined;
}

export interface GetBookingsResponse {
  $type: "api.booking.GetBookingsResponse";
  bookings: Booking[];
}

export interface GetBookingDetailsRequest {
  $type: "api.booking.GetBookingDetailsRequest";
  user?: User | undefined;
  bookingId: string;
}

export interface BookingDetails {
  $type: "api.booking.BookingDetails";
  booking?: Booking | undefined;
}

export interface CreateBookingRequest {
  $type: "api.booking.CreateBookingRequest";
  user?: User | undefined;
  booking?: CreateBookingDto | undefined;
}

export interface UpdateBookingRequest {
  $type: "api.booking.UpdateBookingRequest";
  user?: User | undefined;
  bookingId: string;
  booking?: CreateBookingDto | undefined;
}

export interface DeleteBookingRequest {
  $type: "api.booking.DeleteBookingRequest";
  user?: User | undefined;
  bookingId: string;
}

export interface CreateBookingDto {
  $type: "api.booking.CreateBookingDto";
  itemId: string;
  startTime: string;
  endTime: string;
  note: string;
  status: string;
}

export const API_BOOKING_PACKAGE_NAME = "api.booking";

function createBaseUser(): User {
  return { $type: "api.booking.User", id: "", email: "", username: "" };
}

export const User: MessageFns<User, "api.booking.User"> = {
  $type: "api.booking.User" as const,

  encode(
    message: User,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(User.$type, User);

function createBaseBooking(): Booking {
  return {
    $type: "api.booking.Booking",
    id: "",
    itemId: "",
    userId: "",
    note: "",
    status: "",
  };
}

export const Booking: MessageFns<Booking, "api.booking.Booking"> = {
  $type: "api.booking.Booking" as const,

  encode(
    message: Booking,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.itemId !== "") {
      writer.uint32(18).string(message.itemId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(message.startTime, writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(message.endTime, writer.uint32(42).fork()).join();
    }
    if (message.note !== "") {
      writer.uint32(50).string(message.note);
    }
    if (message.status !== "") {
      writer.uint32(58).string(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(66).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Booking {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBooking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.itemId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.note = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(Booking.$type, Booking);

function createBaseGetBookingsRequest(): GetBookingsRequest {
  return { $type: "api.booking.GetBookingsRequest" };
}

export const GetBookingsRequest: MessageFns<
  GetBookingsRequest,
  "api.booking.GetBookingsRequest"
> = {
  $type: "api.booking.GetBookingsRequest" as const,

  encode(
    message: GetBookingsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetBookingsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBookingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetBookingsRequest.$type, GetBookingsRequest);

function createBaseGetAllBookingsRequest(): GetAllBookingsRequest {
  return { $type: "api.booking.GetAllBookingsRequest" };
}

export const GetAllBookingsRequest: MessageFns<
  GetAllBookingsRequest,
  "api.booking.GetAllBookingsRequest"
> = {
  $type: "api.booking.GetAllBookingsRequest" as const,

  encode(
    message: GetAllBookingsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAllBookingsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllBookingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetAllBookingsRequest.$type, GetAllBookingsRequest);

function createBaseGetBookingsResponse(): GetBookingsResponse {
  return { $type: "api.booking.GetBookingsResponse", bookings: [] };
}

export const GetBookingsResponse: MessageFns<
  GetBookingsResponse,
  "api.booking.GetBookingsResponse"
> = {
  $type: "api.booking.GetBookingsResponse" as const,

  encode(
    message: GetBookingsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.bookings) {
      Booking.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetBookingsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBookingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bookings.push(Booking.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(GetBookingsResponse.$type, GetBookingsResponse);

function createBaseGetBookingDetailsRequest(): GetBookingDetailsRequest {
  return { $type: "api.booking.GetBookingDetailsRequest", bookingId: "" };
}

export const GetBookingDetailsRequest: MessageFns<
  GetBookingDetailsRequest,
  "api.booking.GetBookingDetailsRequest"
> = {
  $type: "api.booking.GetBookingDetailsRequest" as const,

  encode(
    message: GetBookingDetailsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.bookingId !== "") {
      writer.uint32(18).string(message.bookingId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetBookingDetailsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBookingDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bookingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(
  GetBookingDetailsRequest.$type,
  GetBookingDetailsRequest,
);

function createBaseBookingDetails(): BookingDetails {
  return { $type: "api.booking.BookingDetails" };
}

export const BookingDetails: MessageFns<
  BookingDetails,
  "api.booking.BookingDetails"
> = {
  $type: "api.booking.BookingDetails" as const,

  encode(
    message: BookingDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.booking !== undefined) {
      Booking.encode(message.booking, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BookingDetails {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBookingDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.booking = Booking.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(BookingDetails.$type, BookingDetails);

function createBaseCreateBookingRequest(): CreateBookingRequest {
  return { $type: "api.booking.CreateBookingRequest" };
}

export const CreateBookingRequest: MessageFns<
  CreateBookingRequest,
  "api.booking.CreateBookingRequest"
> = {
  $type: "api.booking.CreateBookingRequest" as const,

  encode(
    message: CreateBookingRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.booking !== undefined) {
      CreateBookingDto.encode(message.booking, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateBookingRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBookingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.booking = CreateBookingDto.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(CreateBookingRequest.$type, CreateBookingRequest);

function createBaseUpdateBookingRequest(): UpdateBookingRequest {
  return { $type: "api.booking.UpdateBookingRequest", bookingId: "" };
}

export const UpdateBookingRequest: MessageFns<
  UpdateBookingRequest,
  "api.booking.UpdateBookingRequest"
> = {
  $type: "api.booking.UpdateBookingRequest" as const,

  encode(
    message: UpdateBookingRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.bookingId !== "") {
      writer.uint32(18).string(message.bookingId);
    }
    if (message.booking !== undefined) {
      CreateBookingDto.encode(message.booking, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UpdateBookingRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBookingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bookingId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.booking = CreateBookingDto.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(UpdateBookingRequest.$type, UpdateBookingRequest);

function createBaseDeleteBookingRequest(): DeleteBookingRequest {
  return { $type: "api.booking.DeleteBookingRequest", bookingId: "" };
}

export const DeleteBookingRequest: MessageFns<
  DeleteBookingRequest,
  "api.booking.DeleteBookingRequest"
> = {
  $type: "api.booking.DeleteBookingRequest" as const,

  encode(
    message: DeleteBookingRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.bookingId !== "") {
      writer.uint32(18).string(message.bookingId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DeleteBookingRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBookingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bookingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(DeleteBookingRequest.$type, DeleteBookingRequest);

function createBaseCreateBookingDto(): CreateBookingDto {
  return {
    $type: "api.booking.CreateBookingDto",
    itemId: "",
    startTime: "",
    endTime: "",
    note: "",
    status: "",
  };
}

export const CreateBookingDto: MessageFns<
  CreateBookingDto,
  "api.booking.CreateBookingDto"
> = {
  $type: "api.booking.CreateBookingDto" as const,

  encode(
    message: CreateBookingDto,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.itemId !== "") {
      writer.uint32(10).string(message.itemId);
    }
    if (message.startTime !== "") {
      writer.uint32(18).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(26).string(message.endTime);
    }
    if (message.note !== "") {
      writer.uint32(34).string(message.note);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBookingDto {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBookingDto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.note = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

messageTypeRegistry.set(CreateBookingDto.$type, CreateBookingDto);

export interface BookingServiceClient {
  getBookingsByUserId(
    request: GetBookingsRequest,
  ): Observable<GetBookingsResponse>;

  /** Added for admin */

  getAllBookings(
    request: GetAllBookingsRequest,
  ): Observable<GetBookingsResponse>;

  getBookingDetails(
    request: GetBookingDetailsRequest,
  ): Observable<BookingDetails>;

  createBooking(request: CreateBookingRequest): Observable<Booking>;

  updateBooking(request: UpdateBookingRequest): Observable<Booking>;

  deleteBooking(request: DeleteBookingRequest): Observable<Booking>;
}

export interface BookingServiceController {
  getBookingsByUserId(
    request: GetBookingsRequest,
  ):
    | Promise<GetBookingsResponse>
    | Observable<GetBookingsResponse>
    | GetBookingsResponse;

  /** Added for admin */

  getAllBookings(
    request: GetAllBookingsRequest,
  ):
    | Promise<GetBookingsResponse>
    | Observable<GetBookingsResponse>
    | GetBookingsResponse;

  getBookingDetails(
    request: GetBookingDetailsRequest,
  ): Promise<BookingDetails> | Observable<BookingDetails> | BookingDetails;

  createBooking(
    request: CreateBookingRequest,
  ): Promise<Booking> | Observable<Booking> | Booking;

  updateBooking(
    request: UpdateBookingRequest,
  ): Promise<Booking> | Observable<Booking> | Booking;

  deleteBooking(
    request: DeleteBookingRequest,
  ): Promise<Booking> | Observable<Booking> | Booking;
}

export function BookingServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getBookingsByUserId",
      "getAllBookings",
      "getBookingDetails",
      "createBooking",
      "updateBooking",
      "deleteBooking",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcMethod("BookingService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcStreamMethod("BookingService", method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
  };
}

export const BOOKING_SERVICE_NAME = "BookingService";

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
